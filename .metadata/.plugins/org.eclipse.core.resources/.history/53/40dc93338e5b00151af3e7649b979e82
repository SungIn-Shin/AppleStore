package com.iheart.slkp.server;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;

import com.iheart.slkp.client.SLKPUtil;

public class SLKPServerMain {
	//
	private ServerSocket serverSocket;
	private Socket socket;
	private DataInputStream dis;
	private DataOutputStream dos;

	private String id, pwd;

	public SLKPServerMain() {
		//
		id = "test";
		pwd = "test";
		try {

			serverSocket = new ServerSocket(9999);
			System.out.println("서버시작");
			process();

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public void process() {
		byte[] typeArr = new byte[2];
		byte[] lenArr = new byte[2];
		byte[] messageArr = null;
		String type = "";
		int len = 0;
		String message = "";
		while (true) {
			try {
				socket = serverSocket.accept();
				System.out.println("소켓 접속함 : " + socket.getInetAddress());
				dis = new DataInputStream(socket.getInputStream());

				// 앞에서 4바이트 (Header)만 읽어들인다
				for (int i = 0; i < 2; i++) {
					typeArr[i] = dis.readByte();
				}

				for (int i = 0; i < 2; i++) {
					lenArr[i] = dis.readByte();
				}

				type = new String(typeArr);
				System.out.println("Type : " + type);

				len = SLKPUtil.byteArrayToShort(lenArr, 0);
				System.out.println("Length : " + len);

				if (type.equals("AB")) {
					// 인증 프로토콜
					messageArr = new byte[len + 1];
					for (int i = 0; i < len; i++) {
						messageArr[i] = dis.readByte();
					}
					message = new String(messageArr);
					String[] split = message.split("/");
					String userId = split[0].trim();
					String userPwd = split[1].trim();
				

					if (userId.equals(id)  && userPwd.equals(pwd)) {
						System.out.println("사용자 인증 성공");
					} else {
						System.out.println("사용자 인증 실패 연결을 끊습니다.");
					}

				} else {

					messageArr = new byte[len + 1];
					for (int i = 0; i < len; i++) {
						messageArr[i] = dis.readByte();
					}
					message = new String(messageArr);
					System.out.println("Message : " + message);
				}
			} catch (IOException e) {
				//
				e.printStackTrace();
			} finally {
				try {
					dis.close();
				} catch (IOException e) {
					//
					e.printStackTrace();
				}
			}
		}
	}
	
	private ByteBuffer makeProtocol(String msg, String type) {
		int msgLength = msg.getBytes().length;
		System.out.println("메세지 길이 : " + msgLength);
		
		int maxLength = 2 + 2 + msgLength + 1;
		System.out.println("보내질 배열의 총 길이 : "+ maxLength);
		
		
		byte[] typeToByte = type.getBytes();
		System.out.println("Type의 Byte 길이 : "+ typeToByte.length);
		// Body의 길이 총 byte[] 의 길이 = body의 길이 + 4byte
		// int 는 4byte이기 때문에 2byte로 Header의 length를 2로 잡으려면 short로 변환해야한다.
		short len = (short) msgLength;		
		System.out.println("Body Length : " + len);
		
		byte[] lenToByte = SLKPUtil.shortToByteArray(len);
		System.out.println("len의 Byte 길이 : "+ lenToByte.length);
		
		// 바이트 버퍼의 길이를 4(헤더의 길이) + body의 길이로 지정
				ByteBuffer bb = ByteBuffer.allocate(maxLength);
				bb.clear(); // ByteBuffer의 position값을 limit값과 동일하게 둔다.
				
				/** SLKProtocol HEADER Start **/
				// Type
				bb.limit(2);
				bb.put(typeToByte);
				// Length
				bb.position(2);
				bb.limit(4);
				bb.put(lenToByte);
				/** SLKProtocol HEADER End **/
				
				
				/** SLKProtocol BODY Start **/
				bb.position(4);
				bb.limit(maxLength-1);
				bb.put(msg.getBytes());
				/** SLKProtocol BODY End **/
		return bb;
	}

	public static void main(String[] args) {
		//
		new SLKPServerMain();
	}
}
